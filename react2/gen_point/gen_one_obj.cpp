#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <dirent.h>

#include "rtcommon.h"
#include "arg.h"
#include "read_config.h"

/************************************/

const char *gen_value(db_field_t *dbf, int i, char *buf, int sz)
{
  const char *indent = "          ";
  switch(dbf->type)
  {
    case RT_FLOAT:
      snprintf(buf, sz, ",\n%sargv[%d]", indent, i);
      break;
    case RT_INT:
      snprintf(buf, sz, ",\n%sargv[%d]", indent, i);
      break;
    case RT_BOOL:
      snprintf(buf, sz, 
         ",\n%s((argv[%d][0] == 't') || (argv[%d][0] == 'T') || (argv[%d][0] == 'y') || (argv[%d][0] == 'Y') || (argv[%d][0] == '1')) ? \"'T'\" : \"'F'\"", 
         indent, i, i, i, i, i);
      break;
    case RT_STRING:
      snprintf(buf, sz, ",\n%sargv[%d]", indent, i);
      break;
    case RT_SELECT:
      snprintf(buf, sz, ",\n%sargv[%d]", indent, i);
      break;
    case RT_ARRAY:
      snprintf(buf, sz, ",\n%sargv[%d]", indent, i);
      break;
  }
  return buf;
}

/**********************************************************************/

const char *gen_format(db_field_t *dbf, char *buf, int sz)
{
  switch(dbf->type)
  {
    case RT_FLOAT:
      snprintf(buf, sz, "%%s");
      break;
    case RT_INT:
      snprintf(buf, sz, "%%s");
      break;
    case RT_BOOL:
      snprintf(buf, sz, "%%s");
      break;
    case RT_STRING:
      snprintf(buf, sz, "'%%s'");
      break;
    case RT_SELECT:
      snprintf(buf, sz, "'%%s'");
      break;
    case RT_ARRAY:
      snprintf(buf, sz, "'%%s'");
      break;
  }
  return buf;
}

/**********************************************************************/


void  gen_header(FILE *fp_out, const char *exe_name)
{
  fprintf(fp_out, "/***************************\n");
  fprintf(fp_out, "This is an auto-generated file, do NOT edit!!\n");
  fprintf(fp_out, "   generated by %s\n", exe_name);
  fprintf(fp_out, "***************************/\n");
  fprintf(fp_out, "#include <stdio.h>\n");
  fprintf(fp_out, "#include <sqlite3.h>\n");
  fprintf(fp_out, "#include \"rtcommon.h\"\n");
  fprintf(fp_out, "#include \"arg.h\"\n");
}

/**********************************************************************/

void write_main_start(FILE *fp_out)
{
  fprintf(fp_out, "#include \"gen_common.h\"\n");

  fprintf(fp_out, "int main(int argc, char *argv[])\n");
  fprintf(fp_out, "{\n");
  fprintf(fp_out, "  sqlite3 *sqdb;\n");
  fprintf(fp_out, "  int retval;\n");
  fprintf(fp_out, "  char *errmsg;\n");
  fprintf(fp_out, "\n");
  fprintf(fp_out, "  printf(\"Creating 'react_def.db'\\n\");\n");
  fprintf(fp_out, "  retval = sqlite3_open_v2(\"react_def.db\",  &sqdb,\n");
  fprintf(fp_out, "     SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL);\n");
  fprintf(fp_out, "  if (retval != SQLITE_OK)\n");
  fprintf(fp_out, "  {\n");
  fprintf(fp_out, "    printf(\"Can not open db, error = %%d\\n\", retval);\n");
  fprintf(fp_out, "    printf(\"Err = %%s\\n\", sqlite3_errmsg(sqdb));\n");
  fprintf(fp_out, "    return 0;\n");
  fprintf(fp_out, "  }\n");
  fprintf(fp_out, "  else\n");
  fprintf(fp_out, "  {\n");
  fprintf(fp_out, "    printf(\"SUCCESS\\n\");\n");
  fprintf(fp_out, "  }\n");
  fprintf(fp_out, "  \n");
}

/**********************************************************************/

void write_main_end(FILE *fp_out)
{
  fprintf(fp_out, "  sqlite3_close(sqdb);\n");
  fprintf(fp_out, "}\n");
}

/**********************************************************************/


void  gen_field_header(FILE *fp_out, const char *exe_name)
{
  fprintf(fp_out, "/***************************\n");
  fprintf(fp_out, "This is an auto-generated file, do NOT edit!!\n");
  fprintf(fp_out, "   generated by %s\n", exe_name);
  fprintf(fp_out, "***************************/\n");
  fprintf(fp_out, "#include <stdio.h>\n");
  fprintf(fp_out, "#include <stdlib.h>\n");
  fprintf(fp_out, "#include \"rtcommon.h\"\n");
  fprintf(fp_out, "#include \"arg.h\"\n");
  fprintf(fp_out, "#include \"db_point.h\"\n");
}

/**********************************************************************/

void gen_create_one_field_to_obj(FILE *fp_out, db_field_t *dbf, int argn)
{
  switch (dbf->type)
  {
    case RT_FLOAT:
      fprintf(fp_out, "  objp->%s = atof(argv[%d]);\n", dbf->name, argn);
      break;
    case RT_INT:
      fprintf(fp_out, "  objp->%s = atoi(argv[%d]);\n", dbf->name, argn);
      break;
    case RT_BOOL:
      fprintf(fp_out, "  objp->%s = (argv[%d][0] == '1') ||\n", dbf->name, argn);
      fprintf(fp_out, "             (argv[%d][0] == 'T') ||\n", argn);
      fprintf(fp_out, "             (argv[%d][0] == 't');\n", argn);
      break;
    case RT_STRING:
      fprintf(fp_out, "  safe_strcpy(objp->%s, (const char*) argv[%d], sizeof(objp->%s));\n", dbf->name, argn, dbf->name);
      break;
    case RT_SELECT:
      break;
    case RT_ARRAY:
      break;
  }
}
/*
struct db_field_t
{
  field_type_t type;
  int length;
  char *prompt;
  char *name;
  int n_select;
  char **select_prompts;
  char **select_names;
  
};
*/

/**********************************************************************/

void gen_create_fields_to_obj(FILE *fp_out, gen_names_t *gnames)
{
  fprintf(fp_out, "\n\n/***************************/\n\n");
  //calc_point_t *calc_point_t::read_one(int argc, char *argv[], char *err, int esz);
  fprintf(fp_out, "%s *%s::create_one(int argc, char *argv[], char *err, int esz)\n", 
          gnames->obj_type, gnames->obj_type);
  fprintf(fp_out, "{\n");

  fprintf(fp_out, "  %s *objp;\n", gnames->obj_type);
  fprintf(fp_out, "  objp = new %s;\n", gnames->obj_type);
  fprintf(fp_out, "  if (objp == NULL)\n");
  fprintf(fp_out, "  {\n");
  fprintf(fp_out, "    perror(\"new %s\");\n", gnames->obj_type);
  fprintf(fp_out, "    return NULL;\n");
  fprintf(fp_out, "  }\n");
  

  for (int i=0; i < gnames->nf; i++)
  {
    gen_create_one_field_to_obj(fp_out, gnames->dbfs[i], i);
  }
  fprintf(fp_out, "  return objp;\n");
  fprintf(fp_out, "}\n");
}

/**********************************************************************/

void gen_read_one_db(FILE *fp_out, gen_names_t *gnames)
{
  fprintf(fp_out, "    /*--------*/\n");
  fprintf(fp_out, "\n");
  fprintf(fp_out, "  printf(\"---- Reading database '%s' -------------\\n\");", gnames->table_name);
  fprintf(fp_out, "\n");
  fprintf(fp_out, "%s\n", "  cbdata.first = false;");
  fprintf(fp_out, "%s\n", "  cbdata.n = 0;");
  fprintf(fp_out, "  cbdata.nf = %d;\n", gnames->nf);
  fprintf(fp_out, "  retval = sqlite3_exec(sqdb, \"select * from '%s';\",\n", gnames->table_name);
  fprintf(fp_out, "%s\n", "             my_callback, &cbdata, &errmsg);");
  fprintf(fp_out, "%s\n", "  if (retval != SQLITE_OK)");
  fprintf(fp_out, "%s\n", "  {");
  fprintf(fp_out, "%s\n", "    printf(\"Can not execute query, error = %d\\n\", retval);");
  fprintf(fp_out, "%s\n", "    if (errmsg != NULL)");
  fprintf(fp_out, "%s\n", "    {");
  fprintf(fp_out, "%s\n", "      printf(\"errmsg: %s\\n\", errmsg);");
  fprintf(fp_out, "%s\n", "      sqlite3_free(errmsg);");
  fprintf(fp_out, "%s\n", "    }");
  fprintf(fp_out, "%s\n", "    sqlite3_close(sqdb);");
  fprintf(fp_out, "%s\n", "    return 0;");
  fprintf(fp_out, "%s\n", "  }");
  fprintf(fp_out, "\n");

}


/**********************************************************************/


void gen_callback(FILE *fp_out, gen_names_t gnames) 
{
  fprintf(fp_out, "int %s_callback(void *data, int n, char **vals, char **fields)\n", gnames->table_name);
  fprintf(fp_out, "%s\n", "{");
  fprintf(fp_out, "%s\n", "  callback_data_t *cbdata;");
  fprintf(fp_out, "%s\n", "  cbdata = (callback_data_t *) data; // how to pass data to callback.");
  fprintf(fp_out, "%s\n", "  cbdata->n++;");
  fprintf(fp_out, "%s\n", "  if (cbdata->first) printf(\"First callback!!!\\n\");");
  fprintf(fp_out, "%s\n", "  printf(\"Callback: %d, n = %d\\n\", cbdata->n, n);");
  fprintf(fp_out, "%s\n", "  if (n == cbdata->nf) printf(\"********** number of files MATCH!!\\n\");");
  fprintf(fp_out, "%s\n", "  for (int i=0; i < n; i++)");
  fprintf(fp_out, "%s\n", "  {");
  fprintf(fp_out, "%s\n", "    printf(\"%d: field: '%s', value: '%s'\\n\", i, fields[i], vals[i]);");
  fprintf(fp_out, "%s\n", "  }");
  fprintf(fp_out, "%s\n", "  cbdata->first = false;");
  fprintf(fp_out, "%s\n", "  return 0;");
  fprintf(fp_out, "%s\n", "}");
  fprintf(fp_out, "\n");
  fprintf(fp_out, "/**********************/\n");
}


/*********************************************************************/

void gen_read_db(FILE *fp_out)
{
  fprintf(fp_out, "%s\n", "#include <stdio.h>");
  fprintf(fp_out, "%s\n", "#include <sqlite3.h>");
  fprintf(fp_out, "\n");
  fprintf(fp_out, "%s\n", "struct callback_data_t");
  fprintf(fp_out, "%s\n", "{");
  fprintf(fp_out, "%s\n", "  bool first;");
  fprintf(fp_out, "%s\n", "  int nf;");
  fprintf(fp_out, "%s\n", "  int n;");
  fprintf(fp_out, "%s\n", "};");
  fprintf(fp_out, "\n");
  fprintf(fp_out, "/**********************/\n");
  fprintf(fp_out, "\n");
  fprintf(fp_out, "%s\n", "int my_callback(void *data, int n, char **vals, char **fields)");
  fprintf(fp_out, "%s\n", "{");
  fprintf(fp_out, "%s\n", "  callback_data_t *cbdata;");
  fprintf(fp_out, "%s\n", "  cbdata = (callback_data_t *) data; // how to pass data to callback.");
  fprintf(fp_out, "%s\n", "  cbdata->n++;");
  fprintf(fp_out, "%s\n", "  if (cbdata->first) printf(\"First callback!!!\\n\");");
  fprintf(fp_out, "%s\n", "  printf(\"Callback: %d, n = %d\\n\", cbdata->n, n);");
  fprintf(fp_out, "%s\n", "  if (n == cbdata->nf) printf(\"********** number of files MATCH!!\\n\");");
  fprintf(fp_out, "%s\n", "  for (int i=0; i < n; i++)");
  fprintf(fp_out, "%s\n", "  {");
  fprintf(fp_out, "%s\n", "    printf(\"%d: field: '%s', value: '%s'\\n\", i, fields[i], vals[i]);");
  fprintf(fp_out, "%s\n", "  }");
  fprintf(fp_out, "%s\n", "  cbdata->first = false;");
  fprintf(fp_out, "%s\n", "  return 0;");
  fprintf(fp_out, "%s\n", "}");
  fprintf(fp_out, "\n");
  fprintf(fp_out, "/**********************/\n");
  fprintf(fp_out, "\n");
  fprintf(fp_out, "%s\n", "int main(int argc, char *argv[])");
  fprintf(fp_out, "%s\n", "{");
  fprintf(fp_out, "%s\n", "  sqlite3 *sqdb;");
  fprintf(fp_out, "%s\n", "  sqlite3_stmt *stmt;");
  fprintf(fp_out, "%s\n", "  const char *tail;");
  fprintf(fp_out, "%s\n", "  int retval;");
  fprintf(fp_out, "%s\n", "  char *errmsg;");
  fprintf(fp_out, "%s\n", "  callback_data_t cbdata;");
  fprintf(fp_out, "\n");
  fprintf(fp_out, "%s\n", "  retval = sqlite3_open_v2(\"react_def.db\",  &sqdb,");
  fprintf(fp_out, "%s\n", "     SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL);");
  fprintf(fp_out, "%s\n", "  if (retval != SQLITE_OK)");
  fprintf(fp_out, "%s\n", "  {");
  fprintf(fp_out, "%s\n", "    printf(\"Can not open db, error = %d\\n\", retval);");
  fprintf(fp_out, "%s\n", "    printf(\"Err = %s\\n\", sqlite3_errmsg(sqdb));");
  fprintf(fp_out, "%s\n", "    return 0;");
  fprintf(fp_out, "%s\n", "  }");
  fprintf(fp_out, "\n");
  fprintf(fp_out, "\n");
}

/**********************************************************************/


void gen_write_one(FILE *fp_out, gen_names_t *gnames)
{
  fprintf(fp_out, "\n\n/***************************/\n\n");
  fprintf(fp_out, "int write_one_%s(sqlite3 *sqdb, int argc, char *argv[])\n", 
          gnames->table_name);

  fprintf(fp_out, "{\n");
  //snprintf(str, sizeof(str), "insert into '%s' values(\n"); '%s',%d);",
  //         ddata[i].str, ddata[i].num);

  fprintf(fp_out, "  char qs[1000];");
  fprintf(fp_out, "  int retval;\n");
  fprintf(fp_out, "  char *errmsg;\n");

  fprintf(fp_out, "  if (argc < %d) // There must be at least %d args\n", gnames->nf, gnames->nf);
  fprintf(fp_out, "  {\n");
  fprintf(fp_out, "    return -1;\n");
  fprintf(fp_out, "  }\n");
  char str[5000];
  bool first = true;
  snprintf(str, sizeof(str), 
   "  snprintf(qs, sizeof(qs), \"insert into \\\"%s\\\" values(", 
            gnames->table_name);
  for (int i=0; i < gnames->nf; i++)
  {
    char buf[200];
    if (!first) safe_strcat(str, ",", sizeof(str)); 
    safe_strcat(str, 
           gen_format(gnames->dbfs[i], buf, sizeof(buf)), sizeof(str));
    first = false;
  }
  safe_strcat(str, ");\"", sizeof(str)); 

  for (int i=0; i < gnames->nf; i++)
  {
    char buf[200];
    safe_strcat(str, 
        gen_value(gnames->dbfs[i], i, buf, sizeof(buf)), sizeof(str));
  }
  safe_strcat(str, ");", sizeof(str)); 
  fprintf(fp_out, "  %s\n", str);

  
  fprintf(fp_out, "  printf(\"qs =%%s\\n\", qs);\n");
  fprintf(fp_out, "  retval = sqlite3_exec(sqdb, qs,\n");
  fprintf(fp_out, "             NULL, NULL, &errmsg);\n");
  fprintf(fp_out, "  if (retval != SQLITE_OK)\n");
  fprintf(fp_out, "  {\n");
  fprintf(fp_out, "    printf(\"qs = %%s\\n\", qs);\n");
  fprintf(fp_out, "    printf(\"Can not execute query, error = %%d\\n\", retval);\n");
  fprintf(fp_out, "    if (errmsg != NULL)\n");
  fprintf(fp_out, "    {\n");
  fprintf(fp_out, "      printf(\"errmsg: %%s\\n\", errmsg);\n");
  fprintf(fp_out, "      sqlite3_free(errmsg);\n");
  fprintf(fp_out, "    }\n");
  fprintf(fp_out, "    return -1;\n");
  fprintf(fp_out, "  }\n");
  fprintf(fp_out, "  return 0;\n");

  fprintf(fp_out, "}\n");
}
  
/**********************************************************************/

void process_dat_file(FILE *fp_out, gen_names_t *gnames)
{
  char **argv;
  int argc;
  int line_num;

  delim_file_t df(300, 20, '|', '#');
  df.print_lines(true);


  for (argv = df.first(gnames->field_file_name, &argc, &line_num);
         (argv != NULL);
            argv = df.next(&argc, &line_num))
  {
    if (argc < 2)
    {
    }
  }
}

/**********************************************************************/

void gen_create_table(FILE *fp, gen_names_t *gnames)
{
  char fspec[100];
  char qs[5000];
  snprintf(qs, sizeof(qs), "create table %s(", gnames->table_name);

  int first = true;
  for (int i=0; i < gnames->nf; i++)
  {
    if (!first) safe_strcat(qs, ", ", sizeof(qs));
    safe_strcat(qs, field_spec(gnames->dbfs[i], fspec, sizeof(fspec)), sizeof(qs));
    first = false;
  }
  safe_strcat(qs, ", PRIMARY KEY (tag)", sizeof(qs));
  safe_strcat(qs, ");", sizeof(qs));

  fprintf(fp, "  retval = sqlite3_exec(sqdb,\n");
  fprintf(fp, "      \"%s\",\n", qs);
  fprintf(fp, "             NULL, NULL, &errmsg);\n");
  fprintf(fp, "  if (retval != SQLITE_OK)\n");
  fprintf(fp, "  {\n");
  fprintf(fp, "    printf(\"query = %s\\n\");\n", qs);
  fprintf(fp, "    printf(\"Can not execute query, error = %%d\\n\", retval);\n");
  fprintf(fp, "    if (errmsg != NULL)\n");
  fprintf(fp, "    {\n");
  fprintf(fp, "      printf(\"errmsg: %%s\\n\", errmsg);\n");
  fprintf(fp, "      sqlite3_free(errmsg);\n");
  fprintf(fp, "    }\n");
  fprintf(fp, "    sqlite3_close(sqdb);\n");
  fprintf(fp, "    return 0;\n");
  fprintf(fp, "  }\n");

}

/**********************************************************************/

void gen_insert_call(FILE *fp, gen_names_t *gnames)
{
  fprintf(fp, "  extern int write_one_%s(sqlite3 *sqdb, int argc, char *argv[]);\n", 
            gnames->table_name);
  fprintf(fp, "  insert_from_dat_file(sqdb, \"%s\", write_one_%s);\n", 
            gnames->data_file_name, gnames->table_name);
}

/**********************************************************************/

void gen_for_one_config(FILE *fp_out, FILE *fp_main, gen_names_t *gnames) 
{
  read_config_file(gnames);
  gen_create_table(fp_main, gnames);
  gen_insert_call(fp_main, gnames);
  gen_write_one(fp_out, gnames);
}

/**********************************************************************/

int main(int argc, char *argv[])
{
  char base_name[100];
  char config_name[100];
  char dat_name[100];
  struct gen_names_t gnames;

  if (argc < 2)
  {
    printf("You must specify a file\n");
    return -1;
  }
 
  snprintf(config_name, sizeof(config_name), "%s", argv[1]);
  int len = strlen(config_name);
  snprintf(base_name, sizeof(base_name), "%s", config_name);
  base_name[len-7] = '\0';
  snprintf(dat_name, sizeof(dat_name), "%s.dat", base_name);
  printf("%s\n", base_name); 
  printf("%s\n", config_name); 
  printf("%s\n", dat_name); 
  gnames.field_file_name = config_name;
  gnames.data_file_name = dat_name;

  const char *out_temp = "write_one_fns.cpp";
  FILE *fp_out = fopen(out_temp, "w");
  if (fp_out == NULL)
  {
    perror(out_temp);
    exit(0);
  }

  const char *out_main = "outmain.cpp";
  FILE *fp_main = fopen(out_main, "w");
  if (fp_main == NULL)
  {
    perror(out_main);
    exit(0);
  }

  const char *out_obj = "out_obj.cpp";
  FILE *fp_out_obj = fopen(out_obj, "w");
  if (fp_out_obj == NULL)
  {
    perror(out_obj);
    exit(0);
  }

  const char *read_db = "read_db.cpp";
  FILE *fp_read_db = fopen(read_db, "w");
  if (fp_read_db == NULL)
  {
    perror(read_db);
    exit(0);
  }

  gen_read_db(fp_read_db);

  gen_header(fp_main, argv[0]);
  write_main_start(fp_main);

  gen_header(fp_out, argv[0]);
  gen_field_header(fp_out_obj, argv[0]);

  gen_for_one_config(fp_out, fp_main, &gnames);
  printf("Calling gen_create_fields_to_obj()\n"); 
  gen_create_fields_to_obj(fp_out_obj, &gnames);
  gen_read_one_db(fp_read_db, &gnames);
  
  write_main_end(fp_main);

  fprintf(fp_read_db, "}\n");

  fclose(fp_out);
  fclose(fp_main);
  fclose(fp_out_obj);
  fclose(fp_read_db);
}

/**********************************************************************/
