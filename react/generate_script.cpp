/************************************************************************
This software is part of React, a control engine
Copyright (C) 2005,2006 Donald Wayne Carr 

This program is free software; you can redistribute it and/or modify 
it under the terms of the GNU General Public License as published by 
the Free Software Foundation; either version 2 of the License, or 
(at your option) any later version.

This program is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
General Public License for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
***********************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <sys/timeb.h>

#include "db.h"
#include "secuencia.h"

#include "rtcommon.h"

FILE *header_fp;
FILE *code_fp;
FILE *case_fp;

static const char *header_name = "gen_script.h";
static const char *case_name = "gen_case.cpp";
static const char *code_name = "gen_script.cpp";
static const bool debug = false;

/*********************************************************************/

void generate_heading(FILE *fp, const char *fname)
{
  fprintf(fp, "/*******************************************************\n");
  fprintf(fp, " *   Fille name: %s\n", fname);
  fprintf(fp, " *   Generated by: %s\n", __FILE__);
  fprintf(fp, " * WARNING: this is an autogenerated file, ");
  fprintf(fp, "DO NOT EDIT\n");

  fprintf(fp, " *******************************************************/\n");

  fprintf(fp, "\n");

}

/*********************************************************************/

void generate_ifndef(FILE *fp, const char *fname)
{
  char str[100];
  char *p;
  safe_strcpy(str, "__", sizeof(str));
  safe_strcat(str, fname, sizeof(str));
  for (p = str; (*p != '\0'); p++)
  {
    *p = toupper(*p);
  }
  p -= 2;
  *p = '\0';
  safe_strcat(str, "_INC__", sizeof(str));
  fprintf(fp, "#ifndef %s\n", str);
  fprintf(fp, "#define %s\n", str);
}

/*********************************************************************/

const char *find_second_arg(char *str)
{
  char *p;
  for (p = str; (*p != '\0') && is_a_space(*p); p++);
  if (*p == '\0')
  {
    return "Error";
  }
  for ( ; (*p != '\0') && !is_a_space(*p); p++);
  if (*p == '\0')
  {
    return "Error";
  }
  for ( ; (*p != '\0') && is_a_space(*p); p++);
  if (*p == '\0')
  {
    return "Error";
  }
  char *start = p;
  for ( ; (*p != '\0') && !is_a_space(*p); p++);
  *p = '\0';
  return start;
}

/************************************************************/

script_param_t  script_string_to_type(char *str)
{
   if ((0 == strcmp(str, "double")) || (0 == strcmp(str, "float")))
   {
     return PARAM_DOUBLE;
   }
   else if (0 == strcmp(str, "bool"))
   {
     return PARAM_BOOL;
   }
   else if (0 == strcmp(str, "int"))
   {
     return PARAM_INT;
   }
   else if (0 == strcmp(str, "void"))
   {
     return PARAM_VOID;
   }
   else
   {
     return PARAM_BAD;
   }
}

/************************************************************/

const char *script_type_to_string(script_param_t tp)
{
   const char *str;
   switch (tp)
   {
     case PARAM_DOUBLE:
	     str = "double";
	     break;
     case PARAM_BOOL:
	     str = "bool";
	     break;
     case PARAM_INT:
	     str = "int";
	     break;
     case PARAM_VOID:
	     str = "void";
	     break;
     default:
	     str = "unknown type";
	     break;

   }
   return str;
}

/************************************************************/

const char *script_type_to_type_string(script_param_t tp)
{
   const char *str;
   switch (tp)
   {
     case PARAM_DOUBLE:
	     str = "PARAM_DOUBLE";
	     break;
     case PARAM_BOOL:
	     str = "PARAM_BOOL";
	     break;
     case PARAM_INT:
	     str = "PARAM_INT";
	     break;
     case PARAM_VOID:
	     str = "PARAM_VOID";
	     break;
     default:
	     str = "PARAM_BAD";
	     break;
   }
   return str;
}

/************************************************************/

bool checkdouble(char *param)
{
  return true;
}

/************************************************************/

bool checkbool(char *param)
{
  return true;
}

/************************************************************/

bool checkint(char *param)
{
  return true;
}

/************************************************************/

bool check_param(char *param, script_param_t tp, char *error, int esize)
{
   bool retval;
   switch (tp)
   {
     case PARAM_DOUBLE:
	     retval = checkdouble(param);
	     break;
     case PARAM_BOOL:
	     retval = checkbool(param);
	     break;
     case PARAM_INT:
	     retval = checkint(param);
	     break;
     case PARAM_VOID:
	     retval = false;
	     break;
     default:
	     retval = false;
	     break;
   }
   return retval;
}

/************************************************************/

void generate_case_start(void)
{

  fprintf(case_fp, "secuencia_step_t *create_object_step(int argc, char *argv[], char *error, int esize)\n");
  fprintf(case_fp, "{\n");
//  fprintf(case_fp, "  secuencia_step_t *step;\n");
  fprintf(case_fp, "  db_point_t *db_point;\n");
  fprintf(case_fp, "  db_point = db->get_db_point(argv[0]);\n");
  fprintf(case_fp, "  if (db_point == NULL)\n");
  fprintf(case_fp, "  {\n");
  fprintf(case_fp, "    snprintf(error, esize, \"Tag not found: %%s\", argv[0]);\n");
  fprintf(case_fp, "    return NULL;\n");
  fprintf(case_fp, "  }\n");
  fprintf(case_fp, "  switch(db_point->point_type())\n");
  fprintf(case_fp, "  {\n");
}

/************************************************************/

void generate_case_step(char *enum_type,
		char *fn_names[], char *fn_types[], int n_fns)
{
  fprintf(case_fp, "    case %s:\n", enum_type);
  bool first = true;
  for (int i=0; i < n_fns; i++)
  {
    if (first)
    {
      fprintf(case_fp, "      ");
      first = false;
    }
    else
    {
      fprintf(case_fp, "      else ");
    }

    fprintf(case_fp, "if (0 == strcasecmp(argv[1], \"%s\"))\n",
		    fn_names[i]);
    fprintf(case_fp, "      {\n");
    fprintf(case_fp, "        return new %s(argc, argv, error, esize);\n",
		    fn_types[i]);
    fprintf(case_fp, "      }\n");
  }
  fprintf(case_fp, "      else\n");
  fprintf(case_fp, "      {\n");
  fprintf(case_fp, "        snprintf(error, esize, \"No such function for %s: %%s\", argv[1]);\n",
		  enum_type);
  fprintf(case_fp, "        return NULL;\n");
  fprintf(case_fp, "      }\n");
  fprintf(case_fp, "      break;\n");
}
/************************************************************/

void generate_case_end(void)
{
  fprintf(case_fp, "    default:\n");
  fprintf(case_fp, "      snprintf(error, esize, \"This point type does not have any functions: %%s\", argv[0]);\n");
  fprintf(case_fp, "      return NULL;\n");
  fprintf(case_fp, "      break;\n");
  fprintf(case_fp, "  }\n");
  fprintf(case_fp, "}\n");
}

/************************************************************/

void generate_set_param(const char *script_obj_type,
		script_param_t ptypes[], int n_params)
{
  fprintf(code_fp, "void %s::set_param(int n, char *param)\n{\n",
		  script_obj_type);
  fprintf(code_fp, "  switch (n)\n");
  fprintf(code_fp, "  {\n");
  for (int i = 0; i < n_params; i++)
  {
    fprintf(code_fp, "    case %d:\n", i);
    fprintf(code_fp, "      p%d = ", i);
    switch (ptypes[i])
    {
      case PARAM_DOUBLE:
        fprintf(code_fp, "atof(param);\n");
	break;
      case PARAM_BOOL:
        fprintf(code_fp, "(param[0] == 'T') ||\n");
        fprintf(code_fp, "        (param[0] == 't') ||\n");
        fprintf(code_fp, "        (param[0] == '1');\n");
	break;
      case PARAM_INT:
        fprintf(code_fp, "atol(param)\n");
	break;
      case PARAM_STRING:
        fprintf(code_fp, "param;\n");
	break;
      case PARAM_VOID:
        fprintf(code_fp, "PARAM_VOID;\n");
	break;
      case PARAM_BAD:
        fprintf(code_fp, "PARAM_BAD;\n");
	break;
    }
    fprintf(code_fp, "      break;\n");
  }
  fprintf(code_fp, "  }\n");
  fprintf(code_fp, "}\n");
  fprintf(code_fp, "\n/***************/\n\n");
}

/************************************************************/

void generate_constructor(const char *script_obj_type, const char *obj_type,
    const char *enum_type, const char *fn_name, 
    script_param_t ptypes[], int n_params)
{
  fprintf(code_fp, "%s::%s\n", script_obj_type, script_obj_type);
  fprintf(code_fp, "           (int argc, char *argv[], char *error, int esize)\n");
  fprintf(code_fp, "{\n");
  fprintf(code_fp, "  error[0] = \'\\0\';\n");
  fprintf(code_fp, "  if (argc != %d)\n", n_params + 2);
  fprintf(code_fp, "  {\n");
  fprintf(code_fp, "    obj_ptr = NULL;\n");
  fprintf(code_fp, "    obj_tag[0] = '\\0';\n");
  fprintf(code_fp, "    is_valid = false;\n");
  fprintf(code_fp,
     "    snprintf(error, esize, \"There should be %d parameter for '%s'\");\n",
      n_params, script_obj_type);
  fprintf(code_fp, "    return;\n");
  fprintf(code_fp, "  }\n");
  fprintf(code_fp, "  safe_strcpy(obj_tag, argv[0], sizeof(obj_tag));\n");
  fprintf(code_fp, "  db_point_t *db_point;\n");
  fprintf(code_fp, "  db_point = db->get_db_point(obj_tag);\n");
  fprintf(code_fp, "  if ((db_point == NULL) ||\n");
  fprintf(code_fp, "      (db_point->point_type() != %s))\n", enum_type);
  fprintf(code_fp, "  {\n");
  fprintf(code_fp, "    obj_ptr = NULL;\n");
  fprintf(code_fp, "    obj_tag[0] = '\\0';\n");
  fprintf(code_fp, "    is_valid = false;\n");
  fprintf(code_fp, "    snprintf(error, esize, \"Bad %s: %%s\", obj_tag);\n",
		  obj_type);
  fprintf(code_fp, "    return;\n");
  fprintf(code_fp, "  }\n");
  fprintf(code_fp, "  obj_ptr = (%s *) db_point;\n", obj_type);
  //printf("ChangeSetpoint: %s, %s, %s\n", pid_point->tag, argv[3], argv[4]);

  if (n_params > 0)
  {
    fprintf(code_fp, "  script_param_t ptypes[] = {");
    for (int i=0; i < n_params; i++)
    {
      if (i != 0)
      {
        fprintf(code_fp, ", ");
      }
      fprintf(code_fp, "%s", script_type_to_type_string(ptypes[i]));
    }
    fprintf(code_fp, "};\n");

    fprintf(code_fp, "  for (int i=2; i < argc; i++)\n");
    fprintf(code_fp, "  {\n");
    fprintf(code_fp, "    if (!check_param(argv[i], ptypes[i-2], error, esize))\n");
    fprintf(code_fp, "    {\n");
    fprintf(code_fp, "      obj_ptr = NULL;\n");
    fprintf(code_fp, "      obj_tag[0] = '\\0';\n");
    fprintf(code_fp, "      is_valid = false;\n");
    fprintf(code_fp, "      return;\n");
    fprintf(code_fp, "    }\n");
    fprintf(code_fp, "  }\n");
    for (int i=0; i < n_params; i++)
    {
      switch (ptypes[i])
      {
        case PARAM_DOUBLE:
          fprintf(code_fp, "  //p%d = ", i);
          fprintf(code_fp, "atof(argv[%d]);\n", i+2);
          fprintf(code_fp, "  expr%d.expr = make_expr(argv[%d]);\n", i, i+2); 
          fprintf(code_fp, "  if (expr%d.expr == NULL)\n", i);
          fprintf(code_fp, "  {\n");
          fprintf(code_fp, "    logfile->vprint(\"Bad expression for '%s.%%s': %%s\\n\", argv[1], rtexperror.str());\n", obj_type);
          fprintf(code_fp, "    expr%d.expr = new expr_op_t[2];\n", i);
          fprintf(code_fp, "    expr%d.expr[0].token_type = FLOAT_VAL;\n", i);
          fprintf(code_fp, "    expr%d.expr[0].val.float_val = 0.0;\n", i);
          fprintf(code_fp, "    expr%d.expr[1].token_type = END_EXPR;\n", i);
          fprintf(code_fp, "    p%d = 0.0;\n", i);
          fprintf(code_fp, "  }\n");
  	  break;
        case PARAM_BOOL:
          fprintf(code_fp, "  //p%d = ", i);
          fprintf(code_fp, "((argv[%d][0] == 'T') ||\n", i+2);
          fprintf(code_fp, "    //(argv[%d][0] == 't') ||\n", i+2);
          fprintf(code_fp, "    //(argv[%d][0] == '1'));\n", i+2);
          fprintf(code_fp, "  expr%d.expr = make_expr(argv[%d]);\n", i, i+2); 
          fprintf(code_fp, "  if (expr%d.expr == NULL)\n", i);
          fprintf(code_fp, "  {\n");
          fprintf(code_fp, "    logfile->vprint(\"Bad expression for '%s.%%s': %%s\\n\", argv[1], rtexperror.str());\n", obj_type);
          fprintf(code_fp, "    expr%d.expr = new expr_op_t[2];\n", i);
          fprintf(code_fp, "    expr%d.expr[0].token_type = LOGICAL_VAL;\n", i);
          fprintf(code_fp, "    expr%d.expr[0].val.logical_val = false;\n", i);
          fprintf(code_fp, "    expr%d.expr[1].token_type = END_EXPR;\n", i);
          fprintf(code_fp, "    p%d = false;\n", i);
          fprintf(code_fp, "  }\n");

	  break;
        case PARAM_INT:
          fprintf(code_fp, "  p%d = ", i);
          fprintf(code_fp, "atol(argv[%d]);\n", i+2);
	  break;
       default:
  	  break;
      }
    }
  }
  fprintf(code_fp, "  snprintf(text, sizeof(text), \"%%s.%s\", obj_tag);\n",
       fn_name);
  fprintf(code_fp, "  is_valid = true;\n");
  fprintf(code_fp, "}\n");
  fprintf(code_fp, "\n/***************/\n\n");
}

/************************************************************/

void generate_execute_function(char *object_type, char *function_name,
		script_param_t ptypes[], int n_params)
{
  fprintf(code_fp, "int %s::execute(double time)\n{\n", object_type);

  for (int i=0; i < n_params; i++)
  {
    switch(ptypes[i])
    {
      case PARAM_DOUBLE:
        fprintf(code_fp, "  if (is_valid)");
        fprintf(code_fp, "  p%d = expr%d.evaluate();\n", i, i); 
        break;
      case PARAM_BOOL:
        fprintf(code_fp, "  if (is_valid)");
        fprintf(code_fp, "  p%d = expr%d.evaluate();\n", i, i); 
        break;
      default:
  	break;
    }
  }
  //fprintf(code_fp, "  printf(\"%%s\\n\", text);\n");
  fprintf(code_fp, "  log_start(text);\n");
  for (int i=0; i < n_params; i++)
  {
    switch(ptypes[i])
    {
      case PARAM_DOUBLE:
        fprintf(code_fp, "  log_double(p%d, ", i);
        break;
      case PARAM_BOOL:
        fprintf(code_fp, "  log_bool(p%d, ", i);
	break;
      case PARAM_INT:
        fprintf(code_fp, "  log_int(p%d, ", i);
	break;
      default:
  	break;
    }
    if (i == 0)
    {
      fprintf(code_fp, "true);\n");
    }
    else
    {
      fprintf(code_fp, "false);\n");
    }
  }
  fprintf(code_fp, "  log_end();\n");

  fprintf(code_fp, "  if (is_valid)\n  {\n");
  fprintf(code_fp, "    obj_ptr->%s(", function_name);
  if (n_params > 0)
  {
    fprintf(code_fp, "p0");
  }
  for (int i=1; i < n_params; i++)
  {
    fprintf(code_fp, ", p%d", i);
  }
  fprintf(code_fp, ");\n");
  fprintf(code_fp, "  }\n");
  fprintf(code_fp, "  return 1;\n");

  fprintf(code_fp, "}\n");
  fprintf(code_fp, "\n/***************/\n\n");
}

/************************************************************/

void generate_check_function(char *object_type)
{
  fprintf(code_fp, "bool %s::check(void)\n{\n", object_type);
  fprintf(code_fp, "  return is_valid;\n");
  fprintf(code_fp, "}\n");
  fprintf(code_fp, "\n/***************/\n\n");

}

/************************************************************/

void generate_script_object(char *name, char *type,
		script_param_t ptype[], int n_params)
{
  if (debug) printf("creating script object: %s, %s\n", name, type);
  fprintf(header_fp, "class %s : public secuencia_step_t\n", name);
  fprintf(header_fp, "{\n");
  fprintf(header_fp, "private:\n");
  fprintf(header_fp, "  tag_t obj_tag;\n");
  fprintf(header_fp, "  %s *obj_ptr;\n", type);
  fprintf(header_fp, "  bool is_valid;\n");
  for (int i=0; i < n_params; i++)
  {
    fprintf(header_fp, "  %s p%d;\n", script_type_to_string(ptype[i]), i);
    switch(ptype[i])
    {
      case PARAM_DOUBLE:
        fprintf(header_fp, "  analog_expr_t expr%d;\n", i); 
        break;
      case PARAM_BOOL:
        fprintf(header_fp, "  discrete_expr_t expr%d;\n", i); 
        break;
      default:
        break;
    }
  }
  fprintf(header_fp, "public:\n");
  fprintf(header_fp, "  %s(int argc, char *argv[], char *error, int esize);\n", name);
  fprintf(header_fp, "  ~%s(void) {};\n", name);
  fprintf(header_fp, "  bool check(void);\n");
  fprintf(header_fp, "  void reset(void) {};\n");
  fprintf(header_fp, "  void set_param(int n, char *param);\n");
  fprintf(header_fp, "  int execute(double time);\n");
  fprintf(header_fp, "  step_type_t get_type(void) {return STEP_UNDEFINED;};\n");
  fprintf(header_fp, "};\n");
  fprintf(header_fp, "\n/***************/\n\n");
}

/************************************************************/

bool parse_parameter(char *str, char **name, script_param_t *type)
{
  /*
   * This function parses a single parameter of the form:
   * <type> <white space> <parameter name>
   */
  //printf("parse_parameter: %s\n", str);
  ltrim(str);
  rtrim(str);
  char *p;
  for (p=str; !is_a_space(*p) && (*p != '\0'); p++);
  if (*p == '\0')
  {
    printf("Invalid <type> <parameter>: %s\n", str);
    return false;
  }
  *p = '\0';
  *type = script_string_to_type(str);
  p++;
  *name = p;
  for ( ; is_a_space(*p) && (*p != '\0'); p++);
  if (*p == '\0')
  {
    printf("Invalid <type> <parameter>: %s\n", str);
    return false;
  }
  return true;
}

/************************************************************/

int parse_parameters(char *str, char *names[], script_param_t types[])
{
  /*
   * This function parses the parameters to a function, in otherwords,
   * everything between the left '(' and the right ')'.
   * The form should  be:
   * type1 param1, type2 param2, . . . , typeN paramN
   */
  //printf("parse_parameters: %s\n", str);

  ltrim(str);
  rtrim(str);
  if (0 == strcmp(str, "void"))
  {
    return 0;
  }
  char *last_p = str;
  char *p = find_str(str, ",");

  if (p != NULL)
  {
    //printf("rest: %s\n", p);
    *p = '\0';
    p++;
  }

  int i = 0;
  while (p != NULL)
  {
    if (!parse_parameter(last_p, &(names[i]), &(types[i])))
    {
      return -1;
    }
    last_p = p;
    p = find_str(last_p, ",");
    if (p == NULL)
    {
      i++;
      continue;
    }
    //printf("rest: %s\n", p);
    *p = '\0';
    p++;
    i++;
  }
  if (!parse_parameter(last_p, &(names[i]), &(types[i])))
  {
    return -1;
  }
  //printf("%d parameters found\n", i+1);
  return i + 1;
}

/************************************************************/

int parse_script_function(char *str, char **fn_name, script_param_t *ret_type,
		char *names[], script_param_t types[])
{
  /* This function takes the a function of the following form:
   * double my_function(double param1, int param2, boolean param3)
   * and returns an array of the parameter names, an array of the
   * parameter types, the function name, and the return type.
   */
  char *params;
  char *p;

  //printf("parse_script_function: %s\n", str);
  ltrim(str);
  rtrim(str);
  params = find_str(str, "(");
  if (params == NULL)
  {
    printf("No starting '(' for function\n");
    return -1;
  }
  *params = '\0';
  params++;
  if (!parse_parameter(str, fn_name, ret_type))
  {
    return -1;
  }
  p = find_str(params, ")");
  if (p == NULL)
  {
    printf("No ending ')' for function\n");
    return -1;
  }
  *p = '\0';
  return parse_parameters(params, names, types);
}

/************************************************************/

void print_function( int n, char *fn_name, script_param_t ret_type,
		char *names[], script_param_t types[])
{
  if (n == -1)
  {
    return;
  }
  printf("\n***************\n");
  printf("name = %s, return type = %s\n", fn_name,
		  script_type_to_string(ret_type));
  for (int i=0; i < n; i++)
  {
    printf("p%d, name = %s, type = %s\n", i, names[i],
		  script_type_to_string(types[i]));
  }
  printf("\n***************\n");
}

/************************************************************/

void parse_file(const char *fname)
{
  char *p_names[20];
  script_param_t p_types[20];
  char *fn_name;
  script_param_t ret_type;
  int n_params;

  FILE *fp = fopen(fname, "r");
  if (fp == NULL)
  {
    printf("Can't open file: %s\n", fname);
    exit(-1);
  }

  header_fp = fopen(header_name, "w");
  if (header_fp == NULL)
  {
    printf("Can't open file: %s\n", header_name);
    exit(-1);
  }

  code_fp = fopen(code_name, "w");
  if (code_fp == NULL)
  {
    printf("Can't open file: %s\n", code_name);
    exit(-1);
  }

  case_fp = fopen(case_name, "w");
  if (case_fp == NULL)
  {
    printf("Can't open file: %s\n", case_name);
    exit(-1);
  }


  generate_heading(code_fp, code_name);
  fprintf(code_fp, "#include <stdio.h>\n");
  fprintf(code_fp, "#include <stdlib.h>\n");
  fprintf(code_fp, "#include <string.h>\n");
  fprintf(code_fp, "#include <time.h>\n");
  fprintf(code_fp, "#include <sys/timeb.h>\n");

  fprintf(code_fp, "#include \"db.h\"\n");
  fprintf(code_fp, "#include \"secuencia.h\"\n");
  fprintf(code_fp, "#include \"exp.h\"\n");
  fprintf(code_fp, "#include \"error.h\"\n");
  fprintf(code_fp, "#include \"%s\"\n", header_name);
  fprintf(code_fp, "\n/***************/\n\n");
  generate_heading(header_fp, header_name);
  generate_ifndef(header_fp, header_name);
  fprintf(header_fp, "\n/***************/\n\n");

  generate_heading(case_fp, case_name);
  fprintf(case_fp, "#include <stdio.h>\n");
  fprintf(case_fp, "#include <stdlib.h>\n");
  fprintf(case_fp, "#include <string.h>\n");
  fprintf(case_fp, "#include <time.h>\n");
  fprintf(case_fp, "#include <sys/timeb.h>\n");
  fprintf(case_fp, "#include \"db.h\"\n");
  fprintf(case_fp, "#include \"secuencia.h\"\n");
  fprintf(code_fp, "#include \"exp.h\"\n");
  fprintf(code_fp, "#include \"error.h\"\n");
  fprintf(case_fp, "#include \"%s\"\n", header_name);
  fprintf(case_fp, "\n/***************/\n\n");
  generate_case_start();

  char line[500];
  for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
  {
    if (0 == strncmp(line, "/*#SCRIPT_OBJECT#",17))
    {
      char *enum_start = &line[18];
      char *p;
      for (p=enum_start; (*p != '\0') && (*p != ')'); p++);
      *p = '\0';
      if (debug) printf("Enum type = '%s'\n", enum_start);
      char enum_type[200];
      safe_strcpy(enum_type, enum_start, sizeof(enum_type));
      if (NULL != fgets(line, sizeof(line), fp))
      {
        if (debug) printf("ScriptObject: %s\n", line);
        const char *tmpptr = find_second_arg(line);
	char object_type[100];
	safe_strcpy(object_type, tmpptr, sizeof(object_type));
        if (debug) printf("ObjectType = %s\n", object_type);
	int n_functions = 0;
	char *fn_names[20];
	char *fn_types[20];
        for (int i=0; NULL != fgets(line, sizeof(line), fp); i++)
	{
          if (0 == strncmp(line, "};", 2))
	  {
	    break;
	  }
          if (0 == strncmp(line, "/*#SCRIPT_FUNCTION#*/",21))
	  {
            if (NULL == fgets(line, sizeof(line), fp))
	    {
	      printf(
	        "More lines expected after /*#SCRIPT_FUNCTION#*/ in %s\n",
			      fname);
	      exit(-1);
	    }
	    else
            {
              if (debug) printf("ScriptFunction: %s\n", line);
              n_params = parse_script_function(line, &fn_name, &ret_type,
			      p_names, p_types);
	      if (n_params < 0)
	      {
	        exit(-1);
	      }
	      char script_object_type[200];
	      safe_strcpy(script_object_type, object_type,
                     sizeof(script_object_type));
	      safe_strcat(script_object_type, "_",
                       sizeof (script_object_type));
	      safe_strcat(script_object_type, fn_name,
                       sizeof (script_object_type));
	      safe_strcat(script_object_type, "_t",
                       sizeof (script_object_type));
              generate_script_object(script_object_type, object_type,
		  p_types, n_params);
              generate_constructor(script_object_type, object_type,
                  enum_type, fn_name, p_types, n_params);
              generate_execute_function(script_object_type, fn_name,
			      p_types, n_params);
              generate_check_function(script_object_type);
              if (debug) printf("generate_set_params for %s\n",
			      script_object_type );
              generate_set_param(script_object_type, p_types, n_params);
	      //print_function(n_params, fn_name, ret_type, p_names, p_types);
	      fn_names[n_functions] = strdup(fn_name);
	      fn_types[n_functions] = strdup(script_object_type);
	      n_functions++;
            }
	  }
	}
        generate_case_step(enum_type, fn_names, fn_types, n_functions);
	printf("Object type: %s, %d functions found\n",
			object_type, n_functions);
      }
    }
  }
  generate_case_end();
  fprintf(header_fp, "#endif\n");
  fclose(fp);
  fclose(header_fp);
  fclose(code_fp);
}

/************************************************************/

int main(int argc, char *argv[])
{
  printf ("generating: %s, %s, %s, from %s\n",
		  case_name, code_name, header_name, "db_point.h");
  parse_file("db_point.h");
  return 0;
}
